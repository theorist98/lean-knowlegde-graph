<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Lean Code Graph - Interactive</title>
    <!-- Ensure all relative asset paths resolve under the repo path on GitHub Pages -->
    <base href="./">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
            border: 1px solid #444;
        }
        #code-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            color: #e0e0e0;
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 2000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #code-modal pre {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #333;
        }
        #close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }
        #close-modal:hover {
            color: #ff6b6b;
        }
        .modal-title {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        .agent-type {
            color: #81c784;
            font-size: 12px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>3D Lean Code Knowledge Graph</strong><br>
        Generated from compiled Lean theorem proofs<br><br>
        <strong>Controls:</strong><br>
        üñ±Ô∏è Mouse: Rotate view<br>
        üé° Wheel: Zoom<br>
        üëÜ Hover: View question<br>
        üñ±Ô∏è Click: Show Lean code<br><br>
        <strong>Legend:</strong><br>
        üü¶ Measure Theory<br>
        üü© Functional Analysis<br>
        üü™ Dynamical Systems<br>
        üü® Stochastic Processes<br>
        üüß Fluid Dynamics<br>
        üü• Nuclear Physics
    </div>
    <div id="tooltip"></div>
    <div id="code-modal">
        <button id="close-modal">&times;</button>
        <div id="modal-content"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ---------- Helpers ----------
        // Build URLs that honor <base href="./"> and work on GitHub Pages
        const asset = (p) => new URL(p, document.baseURI).href;

        // Safely escape HTML when injecting code
        function escapeHtml(str) {
            return (str ?? '').toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        // Resolve simulation asset paths:
        // - absolute URLs (http/https/data) pass through
        // - if string contains a slash, treat as relative and resolve with asset()
        // - otherwise assume file lives under public/simulations/
        function resolveSimAsset(p) {
            if (!p) return '';
            if (/^(https?:|data:)/.test(p)) return p;
            const candidate = p.includes('/') ? p : `public/simulations/${p}`;
            return asset(candidate);
        }

        // ---------- Scene setup ----------
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // ---------- Global variables ----------
        const nodes = [];
        const edges = [];
        const nodeObjects = [];
        const edgeObjects = [];
        let leanData = [];
        const ENTRY_BY_NODE_ID = new Map(); // node.id -> full entry

        // ---------- Load Lean data ----------
        async function loadLeanData() {
            try {
                const response = await fetch('public/extracted_lean_questions.json');
                leanData = await response.json();

                console.log(`Loaded ${leanData.length} Lean code entries`);
                createGraphFromLeanData();
            } catch (error) {
                console.error('Failed to load Lean data:', error);
                // Create sample data if loading fails
                createSampleGraph();
            }
        }

        function createGraphFromLeanData() {
            // Clear existing data
            nodes.length = 0;
            ENTRY_BY_NODE_ID.clear();
            nodeObjects.forEach(obj => scene.remove(obj));
            nodeObjects.length = 0;
            edgeObjects.forEach(obj => scene.remove(obj.line));
            edgeObjects.length = 0;

            // Create nodes from Lean data
            leanData.forEach((entry, index) => {
                const node = {
                    id: `lean_${index}`,
                    label: entry.natural_language_question,
                    agent: entry.agent,
                    code: entry.lean_code,
                    timestamp: entry.session_timestamp,
                    // carry simulation_results forward so UI can access it directly
                    simulation_results: entry.simulation_results,
                    x: (Math.random() - 0.5) * 30,
                    y: (Math.random() - 0.5) * 30,
                    z: (Math.random() - 0.5) * 30,
                    vx: 0, vy: 0, vz: 0,
                    fx: 0, fy: 0, fz: 0
                };
                nodes.push(node);
                ENTRY_BY_NODE_ID.set(node.id, entry); // map node id -> full entry

                // Create visual node with color based on agent type
                let color;
                if (entry.agent && entry.agent.includes('MeasureTheory')) {
                    color = 0x2196f3; // Blue
                } else if (entry.agent && entry.agent.includes('Analysis')) {
                    color = 0x4caf50; // Green
                } else if (entry.agent && entry.agent.includes('Dynamics')) {
                    color = 0x9c27b0; // Purple
                } else if (entry.agent && entry.agent.includes('Stochastic')) {
                    color = 0xffeb3b; // Yellow
                } else if (entry.agent && entry.agent.includes('Fluid')) {
                    color = 0xff9800; // Orange
                } else if (entry.agent && entry.agent.includes('Nuclear')) {
                    color = 0xf44336; // Red
                } else {
                    color = 0x607d8b; // Blue Grey
                }

                const geometry = new THREE.SphereGeometry(0.8, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1),
                    shininess: 100
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(node.x, node.y, node.z);
                sphere.userData = { nodeData: node, type: 'node' };
                scene.add(sphere);
                nodeObjects.push(sphere);
            });

            // Create edges based on semantic similarity (agents of same type)
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i];
                    const nodeB = nodes[j];

                    // Connect nodes from same agent type with higher probability
                    const sameAgent = nodeA.agent === nodeB.agent;
                    const shouldConnect = sameAgent ? Math.random() < 0.3 : Math.random() < 0.05;

                    if (shouldConnect) {
                        const edge = {
                            source: nodeA,
                            target: nodeB,
                            weight: sameAgent ? 0.8 : 0.3
                        };
                        edges.push(edge);

                        // Create visual edge
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(nodeA.x, nodeA.y, nodeA.z),
                            new THREE.Vector3(nodeB.x, nodeB.y, nodeB.z)
                        ]);
                        const material = new THREE.LineBasicMaterial({
                            color: sameAgent ? 0x666666 : 0x333333,
                            opacity: sameAgent ? 0.6 : 0.3,
                            transparent: true
                        });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        edgeObjects.push({ line, edge });
                    }
                }
            }

            console.log(`Created graph with ${nodes.length} nodes and ${edges.length} edges`);
        }

        function createSampleGraph() {
            // Fallback sample data if JSON loading fails
            const sampleData = [
                { natural_language_question: "What is a simple probability measure?", agent: "MeasureTheory-Agent", lean_code: "structure SimpleProbability where\n  outcomes : Nat\n  favorable : Nat" },
                { natural_language_question: "What is a linear transformation?", agent: "Analysis-Agent", lean_code: "structure LinearMap where\n  domain : List Nat\n  codomain : List Nat" },
                { natural_language_question: "What is a dynamical system iteration?", agent: "Dynamics-Agent", lean_code: "def iterate (f : Nat ‚Üí Nat) (x : Nat) (n : Nat) : Nat := sorry" }
            ];

            leanData = sampleData;
            createGraphFromLeanData();
        }

        // ---------- Physics simulation ----------
        function updatePhysics() {
            if (nodes.length === 0) return;

            const alpha = 0.1;
            const repulsion = 15;
            const attraction = 0.02;

            // Reset forces
            nodes.forEach(node => {
                node.fx = 0;
                node.fy = 0;
                node.fz = 0;
            });

            // Repulsion between all nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i];
                    const nodeB = nodes[j];

                    const dx = nodeA.x - nodeB.x;
                    const dy = nodeA.y - nodeB.y;
                    const dz = nodeA.z - nodeB.z;
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;

                    const force = repulsion / (distance * distance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    const fz = (dz / distance) * force;

                    nodeA.fx += fx;
                    nodeA.fy += fy;
                    nodeA.fz += fz;
                    nodeB.fx -= fx;
                    nodeB.fy -= fy;
                    nodeB.fz -= fz;
                }
            }

            // Attraction along edges
            edges.forEach(edge => {
                const dx = edge.target.x - edge.source.x;
                const dy = edge.target.y - edge.source.y;
                const dz = edge.target.z - edge.source.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;

                const force = attraction * distance * edge.weight;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                edge.source.fx += fx;
                edge.source.fy += fy;
                edge.source.fz += fz;
                edge.target.fx -= fx;
                edge.target.fy -= fy;
                edge.target.fz -= fz;
            });

            // Update positions
            nodes.forEach(node => {
                node.vx = (node.vx + node.fx) * 0.9;
                node.vy = (node.vy + node.fy) * 0.9;
                node.vz = (node.vz + node.fz) * 0.9;
                node.x += node.vx * alpha;
                node.y += node.vy * alpha;
                node.z += node.vz * alpha;
            });
        }

        // ---------- Mouse interaction ----------
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const codeModal = document.getElementById('code-modal');
        const modalContent = document.getElementById('modal-content');
        const closeModal = document.getElementById('close-modal');

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const nodeData = intersect.object.userData.nodeData;

                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 10 + 'px';
                tooltip.style.top = event.clientY + 10 + 'px';
                const hasSimulation = nodeData.simulation_results ? ' & simulation' : '';
                const simulationIcon = nodeData.simulation_results ? 'üß™ ' : '';
                tooltip.innerHTML = `
                    <strong>${simulationIcon}${nodeData.agent}</strong><br>
                    ${nodeData.label}<br>
                    <small style="color: #888;">Click to view Lean code${hasSimulation}</small>
                `;

                // Highlight node
                intersect.object.material.emissive.setHex(0x444444);

                // Change cursor to pointer
                document.body.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                document.body.style.cursor = 'default';

                // Reset all node highlights
                nodeObjects.forEach(obj => {
                    const baseColor = obj.material.color.getHex();
                    obj.material.emissive.copy(new THREE.Color(baseColor).multiplyScalar(0.1));
                });
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const nodeData = intersects[0].object.userData.nodeData;
                showCodeModal(nodeData);
            }
        }

        async function showCodeModal(nodeData) {
            // Attempt to recover the full entry if simulation_results was not carried over
            const full = (nodeData && nodeData.simulation_results)
                ? nodeData
                : (ENTRY_BY_NODE_ID.get(nodeData.id) ? {
                    ...nodeData,
                    simulation_results: ENTRY_BY_NODE_ID.get(nodeData.id).simulation_results
                  } : nodeData);

            const agentType = (full.agent || '').replace('-Agent', '');

            let modalHTML = `
                <div class="modal-title">${full.label}</div>
                <div class="agent-type">Agent: ${full.agent} | Session: ${full.timestamp || ''}</div>
                <strong>Lean 4 Code:</strong>
                <pre><code>${escapeHtml(full.code)}</code></pre>
            `;

            // Add simulation results if they exist
            if (full.simulation_results) {
                const sim = full.simulation_results;
                modalHTML += `
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #444;">
                        <strong style="color: #4fc3f7;">üß™ Simulation Results</strong>
                        <p style="color: #ccc; margin: 8px 0;">${escapeHtml(sim.simulation_code?.description || 'Simulation details')}</p>
                `;

                // Add simulation images
                if (Array.isArray(sim.images) && sim.images.length > 0) {
                    modalHTML += '<div style="margin: 15px 0;"><strong>Visualizations:</strong></div>';
                    sim.images.forEach((image) => {
                        const src = resolveSimAsset(image.path);
                        const alt = image.description || '';
                        modalHTML += `
                            <div style="margin: 10px 0;">
                                <img src="${src}" alt="${escapeHtml(alt)}"
                                     style="max-width: 100%; height: auto; border: 1px solid #444; border-radius: 4px;">
                                <p style="color: #888; font-size: 12px; margin: 5px 0;"><em>${escapeHtml(alt)}</em></p>
                            </div>
                        `;
                    });
                }

                // Add simulation code details
                if (sim.simulation_code) {
                    const simCode = sim.simulation_code;
                    modalHTML += `
                        <div style="margin: 15px 0;">
                            <strong>Simulation Code:</strong>
                            <div style="background: #1a1a1a; padding: 10px; border-radius: 4px; margin: 8px 0; border: 1px solid #333;">
                                <div style="color: #4fc3f7; margin-bottom: 8px;">üìÅ ${escapeHtml(simCode.file_path || '')}</div>
                                <div style="color: #88c999; margin-bottom: 8px;">Language: ${escapeHtml(simCode.language || '')}</div>
                    `;

                    if (Array.isArray(simCode.key_features) && simCode.key_features.length > 0) {
                        modalHTML += '<div style="color: #ccc; font-size: 13px;"><strong>Key Features:</strong><ul style="margin: 5px 0; padding-left: 20px;">';
                        simCode.key_features.forEach(feature => {
                            modalHTML += `<li>${escapeHtml(feature)}</li>`;
                        });
                        modalHTML += '</ul></div>';
                    }

                    modalHTML += '</div>';
                }

                // Add execution results
                if (sim.execution_results && typeof sim.execution_results === 'object') {
                    const results = sim.execution_results;
                    modalHTML += `
                        <div style="margin: 15px 0;">
                            <strong>Execution Results:</strong>
                            <div style="background: #1a1a1a; padding: 10px; border-radius: 4px; margin: 8px 0; border: 1px solid #333; font-size: 13px;">
                    `;

                    Object.entries(results).forEach(([key, value]) => {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        modalHTML += `<div style="margin: 3px 0;"><span style="color: #88c999;">${escapeHtml(displayKey)}:</span> ${escapeHtml(String(value))}</div>`;
                    });

                    modalHTML += '</div></div>';
                }

                modalHTML += '</div>';
            }

            modalContent.innerHTML = modalHTML;
            codeModal.style.display = 'block';
            tooltip.style.display = 'none';
        }

        function hideCodeModal() {
            codeModal.style.display = 'none';
        }

        // ---------- Event listeners ----------
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        closeModal.addEventListener('click', hideCodeModal);

        // Close modal with Escape key
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                hideCodeModal();
            }
        });

        // ---------- Animation loop ----------
        function animate() {
            requestAnimationFrame(animate);

            updatePhysics();

            // Update visual positions
            nodeObjects.forEach((obj, index) => {
                if (nodes[index]) {
                    const node = nodes[index];
                    obj.position.set(node.x, node.y, node.z);
                }
            });

            // Update edge positions
            edgeObjects.forEach(({ line, edge }) => {
                const positions = line.geometry.attributes.position.array;
                positions[0] = edge.source.x;
                positions[1] = edge.source.y;
                positions[2] = edge.source.z;
                positions[3] = edge.target.x;
                positions[4] = edge.target.y;
                positions[5] = edge.target.z;
                line.geometry.attributes.position.needsUpdate = true;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // ---------- Handle window resize ----------
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Set initial camera position
        camera.position.set(0, 0, 20);

        // ---------- Initialize ----------
        loadLeanData();
        animate();
    </script>
</body>
</html>
