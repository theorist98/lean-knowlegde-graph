<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Lean Code Graph - Interactive</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
            border: 1px solid #444;
        }
        #code-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            color: #e0e0e0;
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 2000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #code-modal pre {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #333;
        }
        #close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }
        #close-modal:hover {
            color: #ff6b6b;
        }
        .modal-title {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        .agent-type {
            color: #81c784;
            font-size: 12px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>3D Lean Code Knowledge Graph</strong><br>
        Generated from compiled Lean theorem proofs<br><br>
        <strong>Controls:</strong><br>
        üñ±Ô∏è Mouse: Rotate view<br>
        üé° Wheel: Zoom<br>
        üëÜ Hover: View question<br>
        üñ±Ô∏è Click: Show Lean code<br><br>
        <strong>Legend:</strong><br>
        üü¶ Measure Theory<br>
        üü© Functional Analysis<br>
        üü™ Dynamical Systems<br>
        üü® Stochastic Processes<br>
        üüß Fluid Dynamics<br>
        üü• Nuclear Physics
    </div>
    <div id="tooltip"></div>
    <div id="code-modal">
        <button id="close-modal">&times;</button>
        <div id="modal-content"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Global variables
        const nodes = [];
        const edges = [];
        const nodeObjects = [];
        const edgeObjects = [];
        let leanData = [];

        // Embedded Lean data (expanded set from extracted_lean_questions.json)
        const embeddedLeanData = [
            {
                "agent": "MeasureTheory-Agent",
                "session_timestamp": "2025-09-09 09:34:54",
                "natural_language_question": "What is the measure theory theorem event_prob_example?",
                "lean_code": "structure SimpleEvent where\n  total_outcomes : Nat\n  successful_outcomes : Nat\ndef event_probability (e : SimpleEvent) : Nat √ó Nat := (e.successful_outcomes, e.total_outcomes)\ntheorem event_prob_example : event_probability ‚ü®20, 8‚ü© = (8, 20) := by rfl"
            },
            {
                "agent": "Analysis-Agent", 
                "session_timestamp": "2025-09-09 09:34:54",
                "natural_language_question": "What is the functional analysis theorem map_additivity?",
                "lean_code": "structure LinearMap where  \n  source : List Nat  \n  target : List Nat  \ndef map (f : LinearMap) (v : List Nat) : List Nat := f.target.map (fun t => t + (v.foldl (¬∑ + ¬∑) 0))  \ntheorem map_additivity (f : LinearMap) (v‚ÇÅ v‚ÇÇ : List Nat) :  \n  map f (v‚ÇÅ ++ v‚ÇÇ) = map f v‚ÇÅ ++ map f v‚ÇÇ := by  \n  simp  \n  rfl"
            },
            {
                "agent": "Dynamics-Agent",
                "session_timestamp": "2025-09-09 09:34:54", 
                "natural_language_question": "What is the dynamical systems theorem iterate_cycle_zero?",
                "lean_code": "structure CycleTransform where  \n  shift : Nat ‚Üí Nat  \ndef iterate_cycle (c : CycleTransform) (start : Nat) (steps : Nat) : Nat := match steps with  \n  | 0 => start  \n  | Nat.succ k => iterate_cycle c (c.shift start) k  \ntheorem iterate_cycle_zero (c : CycleTransform) (start : Nat) : iterate_cycle c start 0 = start := by rfl  \ntheorem iterate_cycle_add (c : CycleTransform) (start : Nat) (n m : Nat) :  \n  iterate_cycle c start (n + m) = iterate_cycle c (iterate_cycle c start n) m := by  \n  induction n with  \n  | zero => simp  \n  | succ n ih => simp [ih]"
            },
            {
                "agent": "MeasureTheory-Agent",
                "session_timestamp": "2025-09-09 09:34:54",
                "natural_language_question": "What is the measure theory theorem chance_example?",
                "lean_code": "structure BasicEvent where\n  totalPossibilities : Nat\n  favorableCount : Nat\ndef eventChance (e : BasicEvent) : Nat √ó Nat := (e.favorableCount, e.totalPossibilities)\ntheorem chance_example : eventChance ‚ü®20, 5‚ü© = (5, 20) := by rfl"
            },
            {
                "agent": "Analysis-Agent",
                "session_timestamp": "2025-09-09 09:34:54",
                "natural_language_question": "What is the functional analysis theorem probability_example?",
                "lean_code": "structure OutcomeSet where  \n  outcomes : List Nat  \n  favorable : List Nat  \ndef calculate_probability (os : OutcomeSet) : Nat √ó Nat := (List.length os.favorable, List.length os.outcomes)  \ntheorem probability_example : calculate_probability ‚ü®[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6]‚ü© = (3, 10) := by rfl"
            },
            {
                "agent": "Dynamics-Agent", 
                "session_timestamp": "2025-09-09 09:34:54",
                "natural_language_question": "What is the dynamical systems theorem transform_identity?",
                "lean_code": "structure StatefulTransform where\n  state : Nat ‚Üí Nat\ndef apply_transform (t : StatefulTransform) (initial : Nat) (iterations : Nat) : Nat := \n  match iterations with\n  | 0 => initial\n  | Nat.succ k => apply_transform t (t.state initial) k\ntheorem transform_identity (t : StatefulTransform) (initial : Nat) : apply_transform t initial 0 = initial := by rfl\ntheorem transform_one_step (t : StatefulTransform) (initial : Nat) : apply_transform t initial 1 = t.state initial := by rfl"
            },
            {
                "agent": "MeasureTheory-Agent",
                "session_timestamp": "2025-09-09 09:44:03",
                "natural_language_question": "What is the measure theory theorem expectation_example?",
                "lean_code": "structure DiscreteRandomVariable where\n  sampleSpace : Nat\n  outcomeProbabilities : List Nat\ndef expectation (rv : DiscreteRandomVariable) : Nat :=\n  List.sum rv.outcomeProbabilities / rv.sampleSpace\ntheorem expectation_example : expectation ‚ü®10, [1, 2, 3, 4]‚ü© = 10 := by simp"
            },
            {
                "agent": "Analysis-Agent",
                "session_timestamp": "2025-09-09 09:44:03",
                "natural_language_question": "What is the functional analysis theorem vector_addition_commutative?",
                "lean_code": "structure InnerProductSpace where\n  elements : List Nat\n  innerProduct : Prod Nat Nat ‚Üí Nat\ndef vectorAddition (u v : InnerProductSpace) : InnerProductSpace :=\n  ‚ü®List.zipWith Nat.add u.elements v.elements, u.innerProduct‚ü©\ntheorem vector_addition_commutative (u v : InnerProductSpace) : vectorAddition u v = vectorAddition v u := by simp"
            },
            {
                "agent": "Dynamics-Agent",
                "session_timestamp": "2025-09-09 09:44:03",
                "natural_language_question": "What is the dynamical systems theorem applyRotation_zero?",
                "lean_code": "structure CircularTransformation where  \n  rotate : Nat ‚Üí Nat  \ndef applyRotation (c : CircularTransformation) (x : Nat) (n : Nat) : Nat := match n with | 0 => x | Nat.succ k => applyRotation c (c.rotate x) k  \ntheorem applyRotation_zero (c : CircularTransformation) (x : Nat) : applyRotation c x 0 = x := by rfl  \ntheorem applyRotation_one (c : CircularTransformation) (x : Nat) : applyRotation c x 1 = c.rotate x := by rfl"
            },
            {
                "agent": "MeasureTheory-Agent",
                "session_timestamp": "2025-09-09 09:59:35",
                "natural_language_question": "What is the measure theory theorem event_prob_example?",
                "lean_code": "structure EventProbability where\n  totalOutcomes : Nat\n  eventCases : Nat\ndef eventProbability (e : EventProbability) : Nat √ó Nat := (e.eventCases, e.totalOutcomes)\ntheorem event_prob_example : eventProbability ‚ü®20, 6‚ü© = (6, 20) := by rfl"
            },
            {
                "agent": "Analysis-Agent",
                "session_timestamp": "2025-09-09 09:59:35",
                "natural_language_question": "What is the functional analysis theorem bounded_compose_bound?",
                "lean_code": "structure BoundedFunction where\n  domain : List Nat\n  range : List Nat\n  bound : Nat\ndef boundedCompose (f g : BoundedFunction) : BoundedFunction := ‚ü®f.domain, g.range, max f.bound g.bound‚ü©\ntheorem bounded_compose_bound (f g : BoundedFunction) : boundedCompose f g = ‚ü®f.domain, g.range, max f.bound g.bound‚ü© := by rfl"
            },
            {
                "agent": "Dynamics-Agent",
                "session_timestamp": "2025-09-09 09:59:35",
                "natural_language_question": "What is the dynamical systems theorem rotate_zero?",
                "lean_code": "structure CircularTransform where\n  rotation : Nat ‚Üí Nat\ndef rotate (t : CircularTransform) (x : Nat) (n : Nat) : Nat := match n with | 0 => x | Nat.succ k => t.rotation (rotate t x k)\ntheorem rotate_zero (t : CircularTransform) (x : Nat) : rotate t x 0 = x := by rfl"
            }
        ];

        // Load Lean data
        async function loadLeanData() {
            try {
                const response = await fetch('./game_results/extracted_lean_questions.json');
                if (response.ok) {
                    leanData = await response.json();
                    console.log('Loaded ' + leanData.length + ' Lean code entries from JSON file');
                } else {
                    throw new Error('Failed to fetch JSON file');
                }
            } catch (error) {
                console.log('Failed to load JSON, using embedded data:', error.message);
                leanData = embeddedLeanData;
                console.log('Using ' + leanData.length + ' embedded entries');
            }
            
            // Always add sample entries for new agent types to demonstrate legend
            var newAgentSamples = [
                {
                    "agent": "Stochastic-Agent",
                    "session_timestamp": "2025-09-12 23:25:00",
                    "natural_language_question": "What is a basic stochastic process theorem?",
                    "lean_code": "structure RandomWalk where\\n  steps : List Int\\n  probability : Nat ‚Üí Nat\\ndef walkStep (rw : RandomWalk) (n : Nat) : Int := rw.steps.get? n |>.getD 0\\ntheorem walk_starts_zero : walkStep ‚ü®[0, 1, -1, 2], fun _ => 1‚ü© 0 = 0 := by rfl"
                },
                {
                    "agent": "FluidDynamics-Agent", 
                    "session_timestamp": "2025-09-12 23:25:00",
                    "natural_language_question": "What is a fluid flow conservation theorem?",
                    "lean_code": "structure FluidFlow where\\n  velocity : List Nat\\n  density : Nat\\ndef massFlow (f : FluidFlow) : Nat := f.density * f.velocity.sum\\ntheorem conservation_example : massFlow ‚ü®[1, 2, 3], 2‚ü© = 12 := by rfl"
                },
                {
                    "agent": "NuclearPhysics-Agent",
                    "session_timestamp": "2025-09-12 23:25:00", 
                    "natural_language_question": "What is a nuclear decay theorem?",
                    "lean_code": "structure RadioactiveDecay where\\n  halfLife : Nat\\n  initialAmount : Nat\\ndef decayAmount (rd : RadioactiveDecay) (time : Nat) : Nat := rd.initialAmount / (2 ^ (time / rd.halfLife))\\ntheorem decay_at_zero : decayAmount ‚ü®10, 100‚ü© 0 = 100 := by rfl"
                }
            ];
            
            // Add new agent samples to existing data
            for (var i = 0; i < newAgentSamples.length; i++) {
                leanData.push(newAgentSamples[i]);
            }
            
            console.log('Final dataset has ' + leanData.length + ' total entries');
            console.log('First few entries:', leanData.slice(0, 3));
            console.log('Last few entries:', leanData.slice(-3));
            createGraphFromLeanData();
        }

        function createGraphFromLeanData() {
            console.log('Starting graph creation with', leanData.length, 'entries');
            
            // Clear existing data
            nodes.length = 0;
            nodeObjects.forEach(obj => scene.remove(obj));
            nodeObjects.length = 0;
            edgeObjects.forEach(obj => scene.remove(obj.line));
            edgeObjects.length = 0;

            // Create nodes from Lean data
            leanData.forEach((entry, index) => {
                console.log('Processing entry', index, ':', entry.agent);
                const node = {
                    id: `lean_${index}`,
                    label: entry.natural_language_question,
                    agent: entry.agent,
                    code: entry.lean_code,
                    timestamp: entry.session_timestamp,
                    x: (Math.random() - 0.5) * 30,
                    y: (Math.random() - 0.5) * 30,
                    z: (Math.random() - 0.5) * 30,
                    vx: 0, vy: 0, vz: 0,
                    fx: 0, fy: 0, fz: 0
                };
                nodes.push(node);

                // Create visual node with color based on agent type
                let color;
                if (entry.agent.includes('MeasureTheory')) {
                    color = 0x2196f3; // Blue
                } else if (entry.agent.includes('Analysis')) {
                    color = 0x4caf50; // Green
                } else if (entry.agent.includes('Dynamics')) {
                    color = 0x9c27b0; // Purple
                } else if (entry.agent.includes('Stochastic')) {
                    color = 0xffeb3b; // Yellow
                } else if (entry.agent.includes('FluidDynamics') || entry.agent.includes('Fluid')) {
                    color = 0xff9800; // Orange
                } else if (entry.agent.includes('NuclearPhysics') || entry.agent.includes('Nuclear')) {
                    color = 0xf44336; // Red
                } else {
                    color = 0x607d8b; // Blue Grey
                }

                const geometry = new THREE.SphereGeometry(0.8, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1),
                    shininess: 100
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(node.x, node.y, node.z);
                sphere.userData = { nodeData: node, type: 'node' };
                scene.add(sphere);
                nodeObjects.push(sphere);
            });

            // Create edges based on semantic similarity (agents of same type)
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i];
                    const nodeB = nodes[j];
                    
                    // Connect nodes from same agent type with higher probability
                    const sameAgent = nodeA.agent === nodeB.agent;
                    const shouldConnect = sameAgent ? Math.random() < 0.7 : Math.random() < 0.2;
                    
                    if (shouldConnect) {
                        const edge = {
                            source: nodeA,
                            target: nodeB,
                            weight: sameAgent ? 0.8 : 0.3
                        };
                        edges.push(edge);

                        // Create visual edge
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(nodeA.x, nodeA.y, nodeA.z),
                            new THREE.Vector3(nodeB.x, nodeB.y, nodeB.z)
                        ]);
                        const material = new THREE.LineBasicMaterial({ 
                            color: sameAgent ? 0x888888 : 0x555555,
                            opacity: sameAgent ? 0.8 : 0.5,
                            transparent: true
                        });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        edgeObjects.push({ line, edge });
                    }
                }
            }

            console.log(`Created graph with ${nodes.length} nodes and ${edges.length} edges`);
        }

        function createSampleGraph() {
            // Fallback sample data if JSON loading fails
            const sampleData = [
                { natural_language_question: "What is a simple probability measure?", agent: "MeasureTheory-Agent", lean_code: "structure SimpleProbability where\n  outcomes : Nat\n  favorable : Nat" },
                { natural_language_question: "What is a linear transformation?", agent: "Analysis-Agent", lean_code: "structure LinearMap where\n  domain : List Nat\n  codomain : List Nat" },
                { natural_language_question: "What is a dynamical system iteration?", agent: "Dynamics-Agent", lean_code: "def iterate (f : Nat ‚Üí Nat) (x : Nat) (n : Nat) : Nat := sorry" }
            ];
            
            leanData = sampleData;
            createGraphFromLeanData();
        }

        // Physics simulation
        function updatePhysics() {
            if (nodes.length === 0) return;
            
            const alpha = 0.1;
            const repulsion = 15;
            const attraction = 0.02;

            // Reset forces
            nodes.forEach(node => {
                node.fx = 0;
                node.fy = 0;
                node.fz = 0;
            });

            // Repulsion between all nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i];
                    const nodeB = nodes[j];
                    
                    const dx = nodeA.x - nodeB.x;
                    const dy = nodeA.y - nodeB.y;
                    const dz = nodeA.z - nodeB.z;
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;
                    
                    const force = repulsion / (distance * distance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    const fz = (dz / distance) * force;
                    
                    nodeA.fx += fx;
                    nodeA.fy += fy;
                    nodeA.fz += fz;
                    nodeB.fx -= fx;
                    nodeB.fy -= fy;
                    nodeB.fz -= fz;
                }
            }

            // Attraction along edges
            edges.forEach(edge => {
                const dx = edge.target.x - edge.source.x;
                const dy = edge.target.y - edge.source.y;
                const dz = edge.target.z - edge.source.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;
                
                const force = attraction * distance * edge.weight;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;
                
                edge.source.fx += fx;
                edge.source.fy += fy;
                edge.source.fz += fz;
                edge.target.fx -= fx;
                edge.target.fy -= fy;
                edge.target.fz -= fz;
            });

            // Update positions
            nodes.forEach(node => {
                node.vx = (node.vx + node.fx) * 0.9;
                node.vy = (node.vy + node.fy) * 0.9;
                node.vz = (node.vz + node.fz) * 0.9;
                node.x += node.vx * alpha;
                node.y += node.vy * alpha;
                node.z += node.vz * alpha;
            });
        }

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const codeModal = document.getElementById('code-modal');
        const modalContent = document.getElementById('modal-content');
        const closeModal = document.getElementById('close-modal');

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const nodeData = intersect.object.userData.nodeData;
                
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 10 + 'px';
                tooltip.style.top = event.clientY + 10 + 'px';
                tooltip.innerHTML = `
                    <strong>${nodeData.agent}</strong><br>
                    ${nodeData.label}<br>
                    <small style="color: #888;">Click to view Lean code</small>
                `;
                
                // Highlight node
                intersect.object.material.emissive.setHex(0x444444);
                
                // Change cursor to pointer
                document.body.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                document.body.style.cursor = 'default';
                
                // Reset all node highlights
                nodeObjects.forEach(obj => {
                    const baseColor = obj.material.color.getHex();
                    obj.material.emissive.copy(new THREE.Color(baseColor).multiplyScalar(0.1));
                });
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const nodeData = intersects[0].object.userData.nodeData;
                showCodeModal(nodeData);
            }
        }

        function showCodeModal(nodeData) {
            const agentType = nodeData.agent.replace('-Agent', '');
            
            modalContent.innerHTML = `
                <div class="modal-title">${nodeData.label}</div>
                <div class="agent-type">Agent: ${nodeData.agent} | Session: ${nodeData.timestamp}</div>
                <strong>Lean 4 Code:</strong>
                <pre><code>${nodeData.code}</code></pre>
            `;
            
            codeModal.style.display = 'block';
            tooltip.style.display = 'none';
        }

        function hideCodeModal() {
            codeModal.style.display = 'none';
        }

        // Event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        closeModal.addEventListener('click', hideCodeModal);

        // Close modal with Escape key
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                hideCodeModal();
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            
            // Update visual positions
            nodeObjects.forEach((obj, index) => {
                if (nodes[index]) {
                    const node = nodes[index];
                    obj.position.set(node.x, node.y, node.z);
                }
            });

            // Update edge positions
            edgeObjects.forEach(({ line, edge }) => {
                const positions = line.geometry.attributes.position.array;
                positions[0] = edge.source.x;
                positions[1] = edge.source.y;
                positions[2] = edge.source.z;
                positions[3] = edge.target.x;
                positions[4] = edge.target.y;
                positions[5] = edge.target.z;
                line.geometry.attributes.position.needsUpdate = true;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Set initial camera position
        camera.position.set(0, 0, 20);

        // Initialize
        loadLeanData();
        animate();
    </script>
</body>
</html>